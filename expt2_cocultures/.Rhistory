# other NA's are just missing data (e.g., due to flow cytometry clogs or just plain pipetting mistakes)
absDensity[which(is.na(absDensity$Total_density) & absDensity$Heat<12),]
# the total density data will have to be slightly adjusted for fitting to the models
absDen_forFit <- absDensity %>% filter(Day > 0)
# for the "raw" total density data that will be fitted via negative binomial GLM,
# keep the 0's in the data
# but convert NA's into epsilon values (where epsilon is just below the threshold of detection)
below_threshold_rows <- which(is.na(absDen_forFit$Total_density) & absDen_forFit$Heat>12)
absDen_forFit$Total_density[below_threshold_rows] <- (0.25*50/146)
# for the transformed total density data, apply (x + epsilon) transformation to all values EXCEPT those that used to be NA's
absDen_forFit$TotDen_plusEpsilon <- absDen_forFit$Total_density
absDen_forFit$TotDen_plusEpsilon[-below_threshold_rows] <- absDen_forFit$TotDen_plusEpsilon[-below_threshold_rows] + (0.25*50/146)
rm(below_threshold_rows)
# re-arrange the levels of Heat so that emmeans can be run:
absDen_forFit$Heat <- as.character(absDen_forFit$Heat)
absDen_forFit$Heat[which(absDen_forFit$Heat == 0)] <- "control"
# !!! emmeans expects the control to be the very *last* level !!!
absDen_forFit$Heat <- factor(absDen_forFit$Heat,
levels = c("6", "12", "24", "48", "control"))
# clean up
rm(com)
# load in the stationary phase growth rate estimates from Expt1
load("expt1--all_growthcurve_data.RData")
rm(ALL_data.df, derivs.df, TTD.df) # keep just the dataframe with the growth rate estimates (mu)
# a look-up table for growth rates at 30C
growthrates.df <- Dil_growthrates.df %>% filter(Inoculum == "Stationary",
Temp == 30,
Sample %in% c("BSC001", "BSC005", "BSC019", "CK101")) %>%
arrange(desc(mu))
# a look-up table for resistance to 40C
resist.df <- Dil_growthrates.df %>% filter(Inoculum == "Stationary",
Temp == 40,
Sample %in% c("BSC001", "BSC005", "BSC019", "CK101")) %>%
mutate(resistant = ifelse(mu>0, 1, 0)) %>%
arrange(match(Sample, c("BSC001", "CK101", "BSC019", "BSC005")))
# calculate the average growth rate for the inoculated communities
absDen_forFit <- absDen_forFit %>% mutate(community_expected_mu = (growthrates.df$mu[1]*putida + growthrates.df$mu[2]*protegens + growthrates.df$mu[3]*grimontii + growthrates.df$mu[4]*veronii)/(putida + protegens + grimontii + veronii))
# calculate the average growth rate for the realized communities
temp <- absDensity %>% filter(Heat == 0) %>% group_by(community) %>%
mutate(relDen_putida = Conc_putida/Total_density,
relDen_protegens = Conc_protegens/Total_density,
relDen_grimontii = Conc_grimontii/Total_density,
relDen_veronii = Conc_veronii/Total_density) %>%
summarise(relDen_putida = median(relDen_putida, na.rm = TRUE),
relDen_protegens = median(relDen_protegens, na.rm = TRUE),
relDen_grimontii = median(relDen_grimontii, na.rm = TRUE),
relDen_veronii = median(relDen_veronii, na.rm = TRUE)) %>%
mutate(community_averaged_mu = growthrates.df$mu[1]*relDen_putida + growthrates.df$mu[2]*relDen_protegens + growthrates.df$mu[3]*relDen_grimontii + growthrates.df$mu[4]*relDen_veronii)
# get the community resistances
print(resist.df %>% select(Species, Sample, Temp, mu, resistant)) # recall that only putida is resistant
# so it's easy to get community resistance because it's just the presence/absence of putida
# add the information to the full data set
absDen_forFit <- inner_join(absDen_forFit, temp %>% select(community, community_averaged_mu)) %>%
mutate(resistant = putida)
# remember to also add the community growth rates and resistances to the other data frame (this one is used for the extinction analysis because Heat is numeric here)
absDensity <- inner_join(absDensity,
absDen_forFit %>%
select(community, community_expected_mu, community_averaged_mu, resistant) %>%
distinct())
# clean up
rm(temp, Dil_growthrates.df, resist.df, growthrates.df)
# go back to the complete data that includes NA values for all 4 species on some days
absDen_forOrd <- absDen_forFit %>% select(-Total_density, -Diversity, -community_expected_mu, -community_averaged_mu)
# NA values with Total_density == NA are "true" missing data where I failed to record the flow cytometry measurements on that day due to technical difficulties/mistakes. These can be interpolated by using the median values from the remaining community replicates
## get the median values for all communities, days, and heat treatments
median_vals <- absDen_forOrd %>% group_by(Heat, Day, community) %>%
summarise(Med_putida = median(Conc_putida, na.rm=TRUE),
Med_protegens = median(Conc_protegens, na.rm=TRUE),
Med_grimontii = median(Conc_grimontii, na.rm=TRUE),
Med_veronii = median(Conc_veronii, na.rm=TRUE))
## get the index for the rows with "true" missing values
missing_rows <- which(is.na(absDen_forOrd$TotDen_plusEpsilon))
## loop through the missing values
for(i in missing_rows){
# find the interpolation value in the table of median values
temp_med_val <- median_vals[median_vals$Heat == absDen_forOrd$Heat[i] &
median_vals$Day == absDen_forOrd$Day[i] &
median_vals$community == absDen_forOrd$community[i],]
# replace the NA values with the median values
absDen_forOrd$Conc_putida[i] <- temp_med_val$Med_putida
absDen_forOrd$Conc_protegens[i] <- temp_med_val$Med_protegens
absDen_forOrd$Conc_grimontii[i] <- temp_med_val$Med_grimontii
absDen_forOrd$Conc_veronii[i] <- temp_med_val$Med_veronii
# clean up
rm(temp_med_val)
}
# clean up
rm(median_vals, missing_rows, i)
# on the other hand, NA values where Total_density is epsilon represent flow cytometry counts that were below the threshold of detection. In this case let's assume 1:1 ratios of inoculated strains at a total density equal to epsilon.
epsilon <- min(absDen_forOrd$TotDen_plusEpsilon, na.rm=TRUE)
## get the index for the missing value rows below the threshold of detection
missing_rows <- which(is.na(absDen_forOrd$Conc_putida))
## CommRich NA values were supposed to indicate some differences but that doesn't really matter for us anymore
absDen_forOrd$CommRich <- absDen_forOrd$putida + absDen_forOrd$protegens + absDen_forOrd$grimontii + absDen_forOrd$veronii
for(i in missing_rows){
# replace the NA values with epsilon divided by the inoculated species richness
absDen_forOrd$Conc_putida[i] <- absDen_forOrd$putida[i] * epsilon / absDen_forOrd$CommRich[i]
absDen_forOrd$Conc_protegens[i] <- absDen_forOrd$protegens[i] * epsilon / absDen_forOrd$CommRich[i]
absDen_forOrd$Conc_grimontii[i] <- absDen_forOrd$grimontii[i] * epsilon / absDen_forOrd$CommRich[i]
absDen_forOrd$Conc_veronii[i] <- absDen_forOrd$veronii[i] * epsilon / absDen_forOrd$CommRich[i]
}
# re-order the levels of Heat for better plotting
absDen_forOrd$Heat <- factor(absDen_forOrd$Heat, levels=c("control", "6", "12", "24", "48"))
# finally we can drop the TotDen_plusEpsilon column
absDen_forOrd <- absDen_forOrd %>% select(-TotDen_plusEpsilon)
rm(epsilon, missing_rows, i)
# first we have to widen the data:
# create a column that indicates the treatment day as resistance, early recovery, or late recovery
absDen_forOrd$trtmt_day <- "resist"
absDen_forOrd$trtmt_day[absDen_forOrd$Recov_Day == 1] <- "early_recov"
absDen_forOrd$trtmt_day[absDen_forOrd$Recov_Day == 2] <- "late_recov"
# ENTIRELY ARBITARARILY: I will keep days 1, 3, and 5 for control
absDen_forOrd$trtmt_day[absDen_forOrd$Heat == "control" & absDen_forOrd$Day == 3] <- "early_recov"
absDen_forOrd$trtmt_day[absDen_forOrd$Heat == "control" & absDen_forOrd$Day == 5] <- "late_recov"
# remove day 1 for 12h, 24h, 48h AND day 2 for 48h.
absDen_forOrd <- absDen_forOrd[!(absDen_forOrd$Heat == 12 & absDen_forOrd$Day == 1), ]
absDen_forOrd <- absDen_forOrd[!(absDen_forOrd$Heat == 24 & absDen_forOrd$Day == 1), ]
absDen_forOrd <- absDen_forOrd[!(absDen_forOrd$Heat == 48 & absDen_forOrd$Day == 1), ]
absDen_forOrd <- absDen_forOrd[!(absDen_forOrd$Heat == 48 & absDen_forOrd$Day == 2), ]
# also remove day 2 and day 4 for control.
absDen_forOrd <- absDen_forOrd[!(absDen_forOrd$Heat == "control" & absDen_forOrd$Day == 2), ]
absDen_forOrd <- absDen_forOrd[!(absDen_forOrd$Heat == "control" & absDen_forOrd$Day == 4), ]
# pivot wider to create a column for each of the 4 species on each of the 3 days
absDen_wide_forOrd <- absDen_forOrd %>% select(-Day, -Heat_Day, -Recov_Day) %>%
pivot_wider(names_from = trtmt_day,
values_from = c(Conc_putida, Conc_protegens, Conc_grimontii, Conc_veronii))
# re-name the species abundance over time columns so they are shorter (again for better plotting)
colnames(absDen_wide_forOrd)[9:20] <- c("Pu_Resist", "Pu_earlyR", "Pu_lateR",
"Pt_Resist", "Pt_earlyR", "Pt_lateR",
"Gi_Resist", "Gi_earlyR", "Gi_lateR",
"Vn_Resist", "Vn_earlyR", "Vn_lateR")
absDen_forOrd <- absDen_forFit %>% select(-Total_density, -Diversity, -community_expected_mu, -community_averaged_mu)
View(absDen_forOrd)
absDen_forOrd <- absDen_forFit %>% select(-Total_density, -Diversity, -community_expected_mu, -community_averaged_mu, -resistant)
median_vals <- absDen_forOrd %>% group_by(Heat, Day, community) %>%
summarise(Med_putida = median(Conc_putida, na.rm=TRUE),
Med_protegens = median(Conc_protegens, na.rm=TRUE),
Med_grimontii = median(Conc_grimontii, na.rm=TRUE),
Med_veronii = median(Conc_veronii, na.rm=TRUE))
## get the index for the rows with "true" missing values
missing_rows <- which(is.na(absDen_forOrd$TotDen_plusEpsilon))
## loop through the missing values
for(i in missing_rows){
# find the interpolation value in the table of median values
temp_med_val <- median_vals[median_vals$Heat == absDen_forOrd$Heat[i] &
median_vals$Day == absDen_forOrd$Day[i] &
median_vals$community == absDen_forOrd$community[i],]
# replace the NA values with the median values
absDen_forOrd$Conc_putida[i] <- temp_med_val$Med_putida
absDen_forOrd$Conc_protegens[i] <- temp_med_val$Med_protegens
absDen_forOrd$Conc_grimontii[i] <- temp_med_val$Med_grimontii
absDen_forOrd$Conc_veronii[i] <- temp_med_val$Med_veronii
# clean up
rm(temp_med_val)
}
# clean up
rm(median_vals, missing_rows, i)
# on the other hand, NA values where Total_density is epsilon represent flow cytometry counts that were below the threshold of detection. In this case let's assume 1:1 ratios of inoculated strains at a total density equal to epsilon.
epsilon <- min(absDen_forOrd$TotDen_plusEpsilon, na.rm=TRUE)
## get the index for the missing value rows below the threshold of detection
missing_rows <- which(is.na(absDen_forOrd$Conc_putida))
## CommRich NA values were supposed to indicate some differences but that doesn't really matter for us anymore
absDen_forOrd$CommRich <- absDen_forOrd$putida + absDen_forOrd$protegens + absDen_forOrd$grimontii + absDen_forOrd$veronii
for(i in missing_rows){
# replace the NA values with epsilon divided by the inoculated species richness
absDen_forOrd$Conc_putida[i] <- absDen_forOrd$putida[i] * epsilon / absDen_forOrd$CommRich[i]
absDen_forOrd$Conc_protegens[i] <- absDen_forOrd$protegens[i] * epsilon / absDen_forOrd$CommRich[i]
absDen_forOrd$Conc_grimontii[i] <- absDen_forOrd$grimontii[i] * epsilon / absDen_forOrd$CommRich[i]
absDen_forOrd$Conc_veronii[i] <- absDen_forOrd$veronii[i] * epsilon / absDen_forOrd$CommRich[i]
}
# re-order the levels of Heat for better plotting
absDen_forOrd$Heat <- factor(absDen_forOrd$Heat, levels=c("control", "6", "12", "24", "48"))
# finally we can drop the TotDen_plusEpsilon column
absDen_forOrd <- absDen_forOrd %>% select(-TotDen_plusEpsilon)
rm(epsilon, missing_rows, i)
# first we have to widen the data:
# create a column that indicates the treatment day as resistance, early recovery, or late recovery
absDen_forOrd$trtmt_day <- "resist"
absDen_forOrd$trtmt_day[absDen_forOrd$Recov_Day == 1] <- "early_recov"
absDen_forOrd$trtmt_day[absDen_forOrd$Recov_Day == 2] <- "late_recov"
# ENTIRELY ARBITARARILY: I will keep days 1, 3, and 5 for control
absDen_forOrd$trtmt_day[absDen_forOrd$Heat == "control" & absDen_forOrd$Day == 3] <- "early_recov"
absDen_forOrd$trtmt_day[absDen_forOrd$Heat == "control" & absDen_forOrd$Day == 5] <- "late_recov"
# remove day 1 for 12h, 24h, 48h AND day 2 for 48h.
absDen_forOrd <- absDen_forOrd[!(absDen_forOrd$Heat == 12 & absDen_forOrd$Day == 1), ]
absDen_forOrd <- absDen_forOrd[!(absDen_forOrd$Heat == 24 & absDen_forOrd$Day == 1), ]
absDen_forOrd <- absDen_forOrd[!(absDen_forOrd$Heat == 48 & absDen_forOrd$Day == 1), ]
absDen_forOrd <- absDen_forOrd[!(absDen_forOrd$Heat == 48 & absDen_forOrd$Day == 2), ]
# also remove day 2 and day 4 for control.
absDen_forOrd <- absDen_forOrd[!(absDen_forOrd$Heat == "control" & absDen_forOrd$Day == 2), ]
absDen_forOrd <- absDen_forOrd[!(absDen_forOrd$Heat == "control" & absDen_forOrd$Day == 4), ]
# pivot wider to create a column for each of the 4 species on each of the 3 days
absDen_wide_forOrd <- absDen_forOrd %>% select(-Day, -Heat_Day, -Recov_Day) %>%
pivot_wider(names_from = trtmt_day,
values_from = c(Conc_putida, Conc_protegens, Conc_grimontii, Conc_veronii))
View(absDen_wide_forOrd)
dim(absDen_wide_forOrd)
# re-name the species abundance over time columns so they are shorter (again for better plotting)
colnames(absDen_wide_forOrd)[9:20] <- c("Pu_Resist", "Pu_earlyR", "Pu_lateR",
"Pt_Resist", "Pt_earlyR", "Pt_lateR",
"Gi_Resist", "Gi_earlyR", "Gi_lateR",
"Vn_Resist", "Vn_earlyR", "Vn_lateR")
# The final result depends on the initial random placement of the points
# set seed to make the results reproducible
set.seed(28493)
# keep just the species abundances
abundance_matrix <- as.matrix(absDen_wide_forOrd[,9:20])
# a function to automatically run the NMDS for k = 1 to 10 so we can choose appropriately small number of dimensions for ordination
NMDS.scree <- function(mat) { #where x is the abundance matrix
data.frame(k = 1:10,
# autotransform the data before calculating the bray-curtis dissimilarity
stress = sapply(1:10, function(x) metaMDS(mat, distance = "bray", k = x, autotransform = TRUE)$stress))
}
scree_out <- NMDS.scree(abundance_matrix)
plot(scree_out)
# k=3 looks great
try.NMDS <- metaMDS(abundance_matrix, distance = "bray", k = 3, autotransform = TRUE, trymax=100)
# check the stress value. It should be < 0.2, ideally even < 0.05. (But too low stress values can indicate too many 0 values)
try.NMDS$stress
# let's get a general idea of what this NMDS is separating...
# plot the results for axis 1 & 2
ordiplot(try.NMDS, type = "n") # create blank ordination plot
orditorp(try.NMDS, display = "sites", cex = 0.5, air = 0.1) # add row numbers in black
orditorp(try.NMDS, display = "species", col="red", air = 0.1) # add species names in red
# plot the results for axis 1 & 3
ordiplot(try.NMDS, choices = c(1,3), type = "n") # create blank ordination plot
orditorp(try.NMDS, choices = c(1,3), display = "sites", cex = 0.5, air = 0.1) # add row numbers in black
orditorp(try.NMDS, choices = c(1,3), display = "species", col="red", air = 0.1) # add species names in red
# plot the results for axis 2 & 3
ordiplot(try.NMDS, choices = c(2,3), type = "n") # create blank ordination plot
orditorp(try.NMDS, choices = c(2,3), display = "sites", cex = 0.5, air = 0.1) # add row numbers in black
orditorp(try.NMDS, choices = c(2,3), display = "species", col="red", air = 0.1) # add species names in red
# we already know that presense/absence of protegens is consistently the most important thing for all communities so let's see if that shows up here.
# Let's switch over to ggplot to be certain that everything is labelled correctly.
# define a function (related to vegan) that finds coordinates for drawing a covariance ellipse
# CREDIT: THIS COMES FROM ONE OF THE TUTORIALS ABOVE!!!
veganCovEllipse <- function (cov, center = c(0, 0), scale = 1, npoints = 100) {
theta <- (0:npoints) * 2 * pi/npoints
Circle <- cbind(cos(theta), sin(theta))
t(center + scale * t(Circle %*% chol(cov)))
# finds the centroids and dispersion of the different ellipses based on a grouping factor of your choice
}
nmds_for_ggplot <- cbind(absDen_wide_forOrd[,1:8],
as.data.frame(scores(try.NMDS)$sites))
# create a new factor that defines the combination of heat and protegens
nmds_for_ggplot <- nmds_for_ggplot %>% unite("HeatxProtegens", c(Heat, protegens), remove = FALSE)
nmds_for_ggplot$HeatxProtegens <- factor(nmds_for_ggplot$HeatxProtegens,
levels = c("6_0", "6_1", "12_0", "12_1", "24_0", "24_1", "48_0", "48_1", "control_0", "control_1"))
# create empty dataframes to combine NMDS data with ellipse data
ellipse12_df <- ellipse13_df <- ellipse23_df <- data.frame() # numbers indicate the ordination axes
# adding data for ellipses, using HeatxProtegens as a grouping factor
for(g in levels(nmds_for_ggplot$HeatxProtegens)){
ellipse12_df <- rbind(ellipse12_df, cbind(as.data.frame(with(nmds_for_ggplot[nmds_for_ggplot$HeatxProtegens==g,],
veganCovEllipse(cov.wt(cbind(NMDS1, NMDS2),
wt=rep(1/length(NMDS1),length(NMDS1)))$cov,
center=c(mean(NMDS1),mean(NMDS2)))))
, HeatxProtegens=g))
ellipse13_df <- rbind(ellipse13_df, cbind(as.data.frame(with(nmds_for_ggplot[nmds_for_ggplot$HeatxProtegens==g,],
veganCovEllipse(cov.wt(cbind(NMDS1, NMDS3),
wt=rep(1/length(NMDS1),length(NMDS1)))$cov,
center=c(mean(NMDS1),mean(NMDS3)))))
, HeatxProtegens=g))
ellipse23_df <- rbind(ellipse23_df, cbind(as.data.frame(with(nmds_for_ggplot[nmds_for_ggplot$HeatxProtegens==g,],
veganCovEllipse(cov.wt(cbind(NMDS2, NMDS3),
wt=rep(1/length(NMDS2),length(NMDS2)))$cov,
center=c(mean(NMDS2),mean(NMDS3)))))
, HeatxProtegens=g))
}
# now we separate the HeatxProtegens columns:
ellipse12_df <- ellipse12_df %>% separate(HeatxProtegens, c("Heat", "protegens"))
ellipse12_df$Heat <- factor(ellipse12_df$Heat, levels = levels(nmds_for_ggplot$Heat))
ellipse13_df <- ellipse13_df %>% separate(HeatxProtegens, c("Heat", "protegens"))
ellipse13_df$Heat <- factor(ellipse13_df$Heat, levels = levels(nmds_for_ggplot$Heat))
ellipse23_df <- ellipse23_df %>% separate(HeatxProtegens, c("Heat", "protegens"))
ellipse23_df$Heat <- factor(ellipse23_df$Heat, levels = levels(nmds_for_ggplot$Heat))
nmds_for_ggplot$protegens <- as.character(nmds_for_ggplot$protegens) # this needs to be discrete (could also be a factor)
# and finally we can make the plots:
ggplot(data = nmds_for_ggplot, aes(NMDS1, NMDS2)) +
geom_point(aes(color = Heat, shape = protegens), alpha=0.4) + # adding different colours and shapes for points at different distances
geom_path(data=ellipse12_df, aes(x=NMDS1, y=NMDS2, colour=Heat, linetype=protegens), linewidth=1) + # adding covariance ellipses according to distance # use size argument if ggplot2 < v. 3.4.0
guides(color = guide_legend(override.aes = list(linetype=rep(NA,5)))) + # removes lines from colour part of the legend
scale_colour_viridis_d(option = "plasma", begin=0.05, end = 0.9) +
fave_theme + # not sure why I need this but I do to over-write the default grey theme
labs(title="NMDS of all data (4sp & 3 time-points)")
# axes 1 & 2 again showing just the ellipses (bc it's hard to see protegens effects as it's so overlapped)
ggplot(data = nmds_for_ggplot, aes(NMDS1, NMDS2)) +
geom_path(data=ellipse12_df, aes(x=NMDS1, y=NMDS2, colour=Heat, linetype=protegens), linewidth=1) + # plot just the ellipses
scale_colour_viridis_d(option = "plasma", begin=0.05, end = 0.9) +
fave_theme + # not sure why I need this but I do to over-write the default grey theme
labs(title="NMDS of all data (4sp & 3 time-points)")
ggplot(data = nmds_for_ggplot, aes(NMDS1, NMDS3)) +
geom_point(aes(color = Heat, shape = protegens), alpha=0.4) +
geom_path(data=ellipse13_df, aes(x=NMDS1, y=NMDS3, colour=Heat, linetype=protegens), linewidth=1) +
guides(color = guide_legend(override.aes = list(linetype=rep(NA,5)))) +
scale_colour_viridis_d(option = "plasma", begin=0.05, end = 0.9) +
fave_theme +
labs(title="NMDS of all data (4sp & 3 time-points)")
# axes 1 & 3 again showing just the ellipses
ggplot(data = nmds_for_ggplot, aes(NMDS1, NMDS3)) +
geom_path(data=ellipse13_df, aes(x=NMDS1, y=NMDS3, colour=Heat, linetype=protegens), linewidth=1) +
scale_colour_viridis_d(option = "plasma", begin=0.05, end = 0.9) +
fave_theme +
labs(title="NMDS of all data (4sp & 3 time-points)")
ggplot(data = nmds_for_ggplot, aes(NMDS2, NMDS3)) +
geom_point(aes(color = Heat, shape = protegens), alpha=0.4) +
geom_path(data=ellipse23_df, aes(x=NMDS2, y=NMDS3, colour=Heat, linetype=protegens), linewidth=1) +
guides(color = guide_legend(override.aes = list(linetype=rep(NA,5)))) +
scale_colour_viridis_d(option = "plasma", begin=0.05, end = 0.9) +
fave_theme +
labs(title="NMDS of all data (4sp & 3 time-points)")
# axes 2 & 3 again showing just the ellipses (bc it's hard to see protegens effects as it's so overlapped)
ggplot(data = nmds_for_ggplot, aes(NMDS2, NMDS3)) +
geom_path(data=ellipse23_df, aes(x=NMDS2, y=NMDS3, colour=Heat, linetype=protegens), linewidth=1) +
scale_colour_viridis_d(option = "plasma", begin=0.05, end = 0.9) +
fave_theme +
labs(title="NMDS of all data (4sp & 3 time-points)")
################
# check significance:
# using a PERMANOVA to test the differences in community composition
# This is a PERmutational Multivariate ANalysis Of VAriance and tests the differences between groups, like an ANOVA, but with lots of variables.
# it is essentially a multivariate analysis of variance used to compare groups of objects
nmdsdata_test_Heat <- adonis2(abundance_matrix ~ Heat, absDen_wide_forOrd,
permutations = 999, method = "bray")
print(nmdsdata_test_Heat)
nmdsdata_test_Prot <- adonis2(abundance_matrix ~ protegens, absDen_wide_forOrd,
permutations = 999, method = "bray")
print(nmdsdata_test_Prot)
nmdsdata_test_HeatxProt <- adonis2(abundance_matrix ~ Heat * protegens, absDen_wide_forOrd,
permutations = 999, method = "bray")
print(nmdsdata_test_HeatxProt)
# so these are all significant but is that spurious because the dispersion is different btw groups? (e.g., much smaller for protegens)
##############
# check PERMANOVA assumption of homogeneous group variances
# Bray-curtis distance matrix
dist_mat <- vegdist(abundance_matrix, method = "bray")
# use betadisper test to check for multivariate homogeneity of group variances
dispersion <- betadisper(dist_mat, group = paste(absDen_wide_forOrd$Heat, absDen_wide_forOrd$protegens))
permutest(dispersion)
# yeap! We need to try a different test that is robust to heterogenous group variances...
################
# check significance:
# let's test for significance again using ANOSIM (which is another non-parametric test but this time only considering the ranks)
nmdsdata_test2_HeatxProt <- anosim(dist_mat,
grouping = paste(absDen_wide_forOrd$Heat, absDen_wide_forOrd$protegens),
permutations = 999)
plot(nmdsdata_test2_HeatxProt)
summary(nmdsdata_test2_HeatxProt)
# okay, let's say that we are satisfied with this significance testing...
test <- absDen_wide_forOrd
test$Heat <- as.character(levels(test$Heat))[test$Heat]
test$Heat[test$Heat == "control"] <- 0
test$Heat <- as.numeric(test$Heat)
# let's see what the heat gradient looks like
gg_ordiplot(try.NMDS, groups = absDen_wide_forOrd$protegens, plot = TRUE)
gg_envfit(try.NMDS, env = test$Heat, groups = absDen_wide_forOrd$protegens, plot = TRUE, alpha=0.5) # notice this gradient is not significant!!!
gg_envfit(try.NMDS, env = test$Heat, groups = absDen_wide_forOrd$protegens, plot = TRUE, alpha=0.5, choices=c(1,3))
gg_envfit(try.NMDS, env = test$Heat, groups = absDen_wide_forOrd$protegens, plot = TRUE, alpha=0.5, choices=c(2,3))
# The final result depends on the initial random placement of the points
# set seed to make the results reproducible
set.seed(64576)
# keep just the species abundances
abundance_matrix <- as.matrix(absDen_wide_forOrd[,9:20])
# a function to automatically run the NMDS for k = 1 to 10 so we can choose appropriately small number of dimensions for ordination
NMDS.scree <- function(mat) { #where x is the abundance matrix
data.frame(k = 1:10,
# autotransform the data before calculating the bray-curtis dissimilarity
stress = sapply(1:10, function(x) metaMDS(mat, distance = "bray", k = x, autotransform = TRUE)$stress))
}
scree_out <- NMDS.scree(abundance_matrix)
plot(scree_out)
# k=3 looks great
try.NMDS <- metaMDS(abundance_matrix, distance = "bray", k = 3, autotransform = TRUE, trymax=100)
# check the stress value. It should be < 0.2, ideally even < 0.05. (But too low stress values can indicate too many 0 values)
try.NMDS$stress
# let's get a general idea of what this NMDS is separating...
# plot the results for axis 1 & 2
ordiplot(try.NMDS, type = "n") # create blank ordination plot
orditorp(try.NMDS, display = "sites", cex = 0.5, air = 0.1) # add row numbers in black
orditorp(try.NMDS, display = "species", col="red", air = 0.1) # add species names in red
# plot the results for axis 1 & 3
ordiplot(try.NMDS, choices = c(1,3), type = "n") # create blank ordination plot
orditorp(try.NMDS, choices = c(1,3), display = "sites", cex = 0.5, air = 0.1) # add row numbers in black
orditorp(try.NMDS, choices = c(1,3), display = "species", col="red", air = 0.1) # add species names in red
# plot the results for axis 2 & 3
ordiplot(try.NMDS, choices = c(2,3), type = "n") # create blank ordination plot
orditorp(try.NMDS, choices = c(2,3), display = "sites", cex = 0.5, air = 0.1) # add row numbers in black
orditorp(try.NMDS, choices = c(2,3), display = "species", col="red", air = 0.1) # add species names in red
# we already know that presense/absence of protegens is consistently the most important thing for all communities so let's see if that shows up here.
# Let's switch over to ggplot to be certain that everything is labelled correctly.
# define a function (related to vegan) that finds coordinates for drawing a covariance ellipse
# CREDIT: THIS COMES FROM ONE OF THE TUTORIALS ABOVE!!!
veganCovEllipse <- function (cov, center = c(0, 0), scale = 1, npoints = 100) {
theta <- (0:npoints) * 2 * pi/npoints
Circle <- cbind(cos(theta), sin(theta))
t(center + scale * t(Circle %*% chol(cov)))
# finds the centroids and dispersion of the different ellipses based on a grouping factor of your choice
}
nmds_for_ggplot <- cbind(absDen_wide_forOrd[,1:8],
as.data.frame(scores(try.NMDS)$sites))
# create a new factor that defines the combination of heat and protegens
nmds_for_ggplot <- nmds_for_ggplot %>% unite("HeatxProtegens", c(Heat, protegens), remove = FALSE)
nmds_for_ggplot$HeatxProtegens <- factor(nmds_for_ggplot$HeatxProtegens,
levels = c("6_0", "6_1", "12_0", "12_1", "24_0", "24_1", "48_0", "48_1", "control_0", "control_1"))
# create empty dataframes to combine NMDS data with ellipse data
ellipse12_df <- ellipse13_df <- ellipse23_df <- data.frame() # numbers indicate the ordination axes
# adding data for ellipses, using HeatxProtegens as a grouping factor
for(g in levels(nmds_for_ggplot$HeatxProtegens)){
ellipse12_df <- rbind(ellipse12_df, cbind(as.data.frame(with(nmds_for_ggplot[nmds_for_ggplot$HeatxProtegens==g,],
veganCovEllipse(cov.wt(cbind(NMDS1, NMDS2),
wt=rep(1/length(NMDS1),length(NMDS1)))$cov,
center=c(mean(NMDS1),mean(NMDS2)))))
, HeatxProtegens=g))
ellipse13_df <- rbind(ellipse13_df, cbind(as.data.frame(with(nmds_for_ggplot[nmds_for_ggplot$HeatxProtegens==g,],
veganCovEllipse(cov.wt(cbind(NMDS1, NMDS3),
wt=rep(1/length(NMDS1),length(NMDS1)))$cov,
center=c(mean(NMDS1),mean(NMDS3)))))
, HeatxProtegens=g))
ellipse23_df <- rbind(ellipse23_df, cbind(as.data.frame(with(nmds_for_ggplot[nmds_for_ggplot$HeatxProtegens==g,],
veganCovEllipse(cov.wt(cbind(NMDS2, NMDS3),
wt=rep(1/length(NMDS2),length(NMDS2)))$cov,
center=c(mean(NMDS2),mean(NMDS3)))))
, HeatxProtegens=g))
}
# now we separate the HeatxProtegens columns:
ellipse12_df <- ellipse12_df %>% separate(HeatxProtegens, c("Heat", "protegens"))
ellipse12_df$Heat <- factor(ellipse12_df$Heat, levels = levels(nmds_for_ggplot$Heat))
ellipse13_df <- ellipse13_df %>% separate(HeatxProtegens, c("Heat", "protegens"))
ellipse13_df$Heat <- factor(ellipse13_df$Heat, levels = levels(nmds_for_ggplot$Heat))
ellipse23_df <- ellipse23_df %>% separate(HeatxProtegens, c("Heat", "protegens"))
ellipse23_df$Heat <- factor(ellipse23_df$Heat, levels = levels(nmds_for_ggplot$Heat))
nmds_for_ggplot$protegens <- as.character(nmds_for_ggplot$protegens) # this needs to be discrete (could also be a factor)
# and finally we can make the plots:
ggplot(data = nmds_for_ggplot, aes(NMDS1, NMDS2)) +
geom_point(aes(color = Heat, shape = protegens), alpha=0.4) + # adding different colours and shapes for points at different distances
geom_path(data=ellipse12_df, aes(x=NMDS1, y=NMDS2, colour=Heat, linetype=protegens), linewidth=1) + # adding covariance ellipses according to distance # use size argument if ggplot2 < v. 3.4.0
guides(color = guide_legend(override.aes = list(linetype=rep(NA,5)))) + # removes lines from colour part of the legend
scale_colour_viridis_d(option = "plasma", begin=0.05, end = 0.9) +
fave_theme + # not sure why I need this but I do to over-write the default grey theme
labs(title="NMDS of all data (4sp & 3 time-points)")
# axes 1 & 2 again showing just the ellipses (bc it's hard to see protegens effects as it's so overlapped)
ggplot(data = nmds_for_ggplot, aes(NMDS1, NMDS2)) +
geom_path(data=ellipse12_df, aes(x=NMDS1, y=NMDS2, colour=Heat, linetype=protegens), linewidth=1) + # plot just the ellipses
scale_colour_viridis_d(option = "plasma", begin=0.05, end = 0.9) +
fave_theme + # not sure why I need this but I do to over-write the default grey theme
labs(title="NMDS of all data (4sp & 3 time-points)")
ggplot(data = nmds_for_ggplot, aes(NMDS1, NMDS3)) +
geom_point(aes(color = Heat, shape = protegens), alpha=0.4) +
geom_path(data=ellipse13_df, aes(x=NMDS1, y=NMDS3, colour=Heat, linetype=protegens), linewidth=1) +
guides(color = guide_legend(override.aes = list(linetype=rep(NA,5)))) +
scale_colour_viridis_d(option = "plasma", begin=0.05, end = 0.9) +
fave_theme +
labs(title="NMDS of all data (4sp & 3 time-points)")
# axes 1 & 3 again showing just the ellipses
ggplot(data = nmds_for_ggplot, aes(NMDS1, NMDS3)) +
geom_path(data=ellipse13_df, aes(x=NMDS1, y=NMDS3, colour=Heat, linetype=protegens), linewidth=1) +
scale_colour_viridis_d(option = "plasma", begin=0.05, end = 0.9) +
fave_theme +
labs(title="NMDS of all data (4sp & 3 time-points)")
ggplot(data = nmds_for_ggplot, aes(NMDS2, NMDS3)) +
geom_point(aes(color = Heat, shape = protegens), alpha=0.4) +
geom_path(data=ellipse23_df, aes(x=NMDS2, y=NMDS3, colour=Heat, linetype=protegens), linewidth=1) +
guides(color = guide_legend(override.aes = list(linetype=rep(NA,5)))) +
scale_colour_viridis_d(option = "plasma", begin=0.05, end = 0.9) +
fave_theme +
labs(title="NMDS of all data (4sp & 3 time-points)")
# axes 2 & 3 again showing just the ellipses (bc it's hard to see protegens effects as it's so overlapped)
ggplot(data = nmds_for_ggplot, aes(NMDS2, NMDS3)) +
geom_path(data=ellipse23_df, aes(x=NMDS2, y=NMDS3, colour=Heat, linetype=protegens), linewidth=1) +
scale_colour_viridis_d(option = "plasma", begin=0.05, end = 0.9) +
fave_theme +
labs(title="NMDS of all data (4sp & 3 time-points)")
################
# check significance:
# using a PERMANOVA to test the differences in community composition
# This is a PERmutational Multivariate ANalysis Of VAriance and tests the differences between groups, like an ANOVA, but with lots of variables.
# it is essentially a multivariate analysis of variance used to compare groups of objects
nmdsdata_test_Heat <- adonis2(abundance_matrix ~ Heat, absDen_wide_forOrd,
permutations = 999, method = "bray")
print(nmdsdata_test_Heat)
nmdsdata_test_Prot <- adonis2(abundance_matrix ~ protegens, absDen_wide_forOrd,
permutations = 999, method = "bray")
print(nmdsdata_test_Prot)
nmdsdata_test_HeatxProt <- adonis2(abundance_matrix ~ Heat * protegens, absDen_wide_forOrd,
permutations = 999, method = "bray")
print(nmdsdata_test_HeatxProt)
# so these are all significant but is that spurious because the dispersion is different btw groups? (e.g., much smaller for protegens)
##############
# check PERMANOVA assumption of homogeneous group variances
# Bray-curtis distance matrix
dist_mat <- vegdist(abundance_matrix, method = "bray")
# use betadisper test to check for multivariate homogeneity of group variances
dispersion <- betadisper(dist_mat, group = paste(absDen_wide_forOrd$Heat, absDen_wide_forOrd$protegens))
permutest(dispersion)
# yeap! We need to try a different test that is robust to heterogenous group variances...
################
# check significance:
# let's test for significance again using ANOSIM (which is another non-parametric test but this time only considering the ranks)
nmdsdata_test2_HeatxProt <- anosim(dist_mat,
grouping = paste(absDen_wide_forOrd$Heat, absDen_wide_forOrd$protegens),
permutations = 999)
plot(nmdsdata_test2_HeatxProt)
summary(nmdsdata_test2_HeatxProt)
# okay, let's say that we are satisfied with this significance testing...
test <- absDen_wide_forOrd
test$Heat <- as.character(levels(test$Heat))[test$Heat]
test$Heat[test$Heat == "control"] <- 0
test$Heat <- as.numeric(test$Heat)
# let's see what the heat gradient looks like
gg_ordiplot(try.NMDS, groups = absDen_wide_forOrd$protegens, plot = TRUE)
gg_envfit(try.NMDS, env = test$Heat, groups = absDen_wide_forOrd$protegens, plot = TRUE, alpha=0.5) # notice this gradient is not significant!!!
gg_envfit(try.NMDS, env = test$Heat, groups = absDen_wide_forOrd$protegens, plot = TRUE, alpha=0.5, choices=c(1,3))
gg_envfit(try.NMDS, env = test$Heat, groups = absDen_wide_forOrd$protegens, plot = TRUE, alpha=0.5, choices=c(2,3))
