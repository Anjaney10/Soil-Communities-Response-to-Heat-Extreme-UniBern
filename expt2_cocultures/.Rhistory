geom_vline(xintercept = 0, colour="darkgrey") +
geom_point(position = position_dodge(width = 0.5)) +
geom_errorbarh(position = position_dodge(width = 0.5),
aes(xmin = loCI, xmax = hiCI), height = 0.1) +
scale_colour_manual(values=trtmt_pal) +
labs(x = "Effect Size on Richness",
shape = "protegens\npresent?",
y="Heat duration")
#oh, wow this is why the 3rd model is highly preferred:
# there's a strong interaction between protegens & heat
# we can do a posthoc on this to illustrate statistically significant effects
posthoc_6h <- emmeans(effect_6h, pairwise ~ Trtmt_Day*protegens, data = richness_6h)
posthoc_12h <- emmeans(effect_12h, pairwise ~ Trtmt_Day*protegens, data = richness_12h)
posthoc_24h <- emmeans(effect_24h, pairwise ~ Trtmt_Day*protegens, data = richness_24h)
posthoc_48h <- emmeans(effect_48h, pairwise ~ Trtmt_Day*protegens, data = richness_48h)
# create a data.frame for plotting
div_effects <- data.frame()
div_effects <- rbind(div_effects,
get_posthoc(posthoc_6h, heat_trtmt = 6),
get_posthoc(posthoc_12h, heat_trtmt = 12),
get_posthoc(posthoc_24h, heat_trtmt = 24),
get_posthoc(posthoc_48h, heat_trtmt = 48))
# re-order the levels of Trtmt_Day to go from resistance to recovery then rename them for nice plotting
div_effects$Trtmt_Day <- factor(div_effects$Trtmt_Day,
levels = c("recov_2", "recov_1", "resist"))
levels(div_effects$Trtmt_Day) <- c("Recovery (Day 2)", "Recovery (Day 1)", "Resistance")
# plot with group labels
ggplot(div_effects,
aes(x = est, y = as.factor(Heat), colour = Trtmt_Day, shape=as.logical(protegens))) +
facet_grid(~protegens) +
geom_vline(xintercept = 0, colour="darkgrey") +
geom_point(position = position_dodge(width = 0.5)) +
geom_errorbarh(position = position_dodge(width = 0.5),
aes(xmin = loCI, xmax = hiCI), height = 0.1) +
geom_text(position = position_dodge(width = 0.5),
aes(x=-2.5, label=groups)) +
scale_colour_manual(values=trtmt_pal) +
labs(x = "Effect Size on Richness",
y="Heat duration")
# anyway we can still average over the effect of protegens
# we can do a posthoc on this to illustrate statistically significant effects
posthoc_6h <- emmeans(effect_6h, pairwise ~ Trtmt_Day, data = richness_6h)
posthoc_12h <- emmeans(effect_12h, pairwise ~ Trtmt_Day, data = richness_12h)
posthoc_24h <- emmeans(effect_24h, pairwise ~ Trtmt_Day, data = richness_24h)
posthoc_48h <- emmeans(effect_48h, pairwise ~ Trtmt_Day, data = richness_48h)
# create a data.frame for plotting
div_effects <- data.frame()
div_effects <- rbind(div_effects,
get_posthocTEMP(posthoc_6h, heat_trtmt = 6),
get_posthocTEMP(posthoc_12h, heat_trtmt = 12),
get_posthocTEMP(posthoc_24h, heat_trtmt = 24),
get_posthocTEMP(posthoc_48h, heat_trtmt = 48))
# re-order the levels of Trtmt_Day to go from resistance to recovery then rename them for nice plotting
div_effects$Trtmt_Day <- factor(div_effects$Trtmt_Day,
levels = c("recov_2", "recov_1", "resist"))
levels(div_effects$Trtmt_Day) <- c("Recovery (Day 2)", "Recovery (Day 1)", "Resistance")
# plot with group labels
ggplot(div_effects,
aes(x = est, y = as.factor(Heat), colour = Trtmt_Day)) +
geom_vline(xintercept = 0, colour="darkgrey") +
geom_point(position = position_dodge(width = 0.5)) +
geom_errorbarh(position = position_dodge(width = 0.5),
aes(xmin = loCI, xmax = hiCI), height = 0.1) +
geom_text(position = position_dodge(width = 0.5),
aes(x=-2.5, label=groups)) +
scale_colour_manual(values=trtmt_pal) +
labs(x = "Effect Size on Richness",
y="Heat duration",
title = "averaged over protegens")
rm(div_effects, posthoc_6h, posthoc_12h, posthoc_24h, posthoc_48h,
div_effects_protegens, emm_6h, emm_12h, emm_24h, emm_48h, effect_6h, effect_12h,
effect_24h, effect_48h,
rich48h_H0, rich48h_H1, rich48h_H2, rich48h_H2_1, rich48h_H3,
rich24h_H0, rich24h_H1, rich24h_H2, rich24h_H2_1, rich24h_H3,
rich12h_H0, rich12h_H1, rich12h_H2, rich12h_H2_1, rich12h_H3,
rich6h_H0, rich6h_H1, rich6h_H2, rich6h_H2_1, rich6h_H3,
richness_6h, richness_12h, richness_24h, richness_48h)
## plot effect size of productivity (aka Total absolute density)
plot(ggplot(effectSize,
aes(x=Day,
y=TotDen_plusEpsilon_mean,
colour=CommRich,
group=community)) +
facet_grid(~Heat) +
geom_jitter(alpha=0.2, size=0.8, width=0.05) +
stat_summary(fun=mean, geom="line", alpha=0.9) +
scale_y_log10() +
scale_colour_viridis_d(option = "viridis", end=0.65) +
labs(title="All data", colour="Inoculated\nRichness",
y="Effect size on Total Density+epsilon"))
plot(ggplot(effectSize %>%
filter(protegens==1),
aes(x=Day,
y=TotDen_plusEpsilon_mean,
colour=CommRich,
group=community)) +
facet_grid(~Heat) +
geom_jitter(alpha=0.2, size=0.8, width=0.05) +
stat_summary(fun=mean, geom="line", alpha=0.9) +
scale_y_log10() +
scale_colour_viridis_d(option = "viridis", end=0.65) +
labs(title="Protegens included", colour="Inoculated\nRichness",
y="Effect size on Total Density+epsilon"))
plot(ggplot(effectSize %>%
filter(protegens==0),
aes(x=Day,
y=TotDen_plusEpsilon_mean,
colour=CommRich,
group=community)) +
facet_grid(~Heat) +
geom_jitter(alpha=0.2, size=0.8, width=0.05) +
stat_summary(fun=mean, geom="line", alpha=0.9) +
scale_y_log10() +
scale_colour_viridis_d(option = "viridis", end=0.65) +
labs(title="Protegens excluded", colour="Inoculated\nRichness",
y="Effect size on Total Density+epsilon"))
#####################
# log10(Total Density + epsilon) transformed data
#####################
resist_prod0 <- with(effectSize %>% filter(Last_Heat_Day == TRUE) %>%
mutate(log_TotalDensity_plusE = log(TotDen_plusEpsilon_mean)),
lm(log_TotalDensity_plusE ~ CommRich + Heat + CommRich:Heat))
# Maddy's preferred model
print("RESISTANCE PRODUCTIVITY DATA. SUMMARY OF THE SIMPLEST MODEL:")
summary(resist_prod0)
resist_prod1 <- with(effectSize %>% filter(Last_Heat_Day == TRUE) %>%
mutate(log_TotalDensity_plusE = log(TotDen_plusEpsilon_mean)),
lm(log_TotalDensity_plusE ~ CommRich + withstands_heat + Heat + CommRich:withstands_heat + Heat:withstands_heat + CommRich:Heat))
print("RESISTANCE PRODUCTIVITY DATA. SUMMARY OF THE Putida MODEL:")
summary(resist_prod1)
resist_prod2 <- with(effectSize %>% filter(Last_Heat_Day == TRUE) %>%
mutate(log_TotalDensity_plusE = log(TotDen_plusEpsilon_mean)),
lm(log_TotalDensity_plusE ~ CommRich + protegens + Heat + CommRich:protegens + Heat:protegens + CommRich:Heat))
# compare the nested models
anova(resist_prod0, resist_prod1)
anova(resist_prod0, resist_prod2)
# compare all 3 models
AIC(resist_prod0, resist_prod1, resist_prod2) %>% arrange(AIC)
BIC(resist_prod0, resist_prod1, resist_prod2) %>% arrange(BIC)
# the statistically preferred model
print("")
print("RESISTANCE PRODUCTIVITY DATA. SUMMARY OF THE LOWEST AIC & BIC MODEL:")
print("")
summary(resist_prod2)
plot(resist_prod2)
# clean up
rm (resist_prod0, resist_prod1, resist_prod2)
# plot Maddy's preferred model
plot(ggplot(effectSize %>%
filter(Last_Heat_Day == TRUE),
aes(x=Heat,
y=TotDen_plusEpsilon_mean,
colour=CommRich,
group=CommRich)) +
geom_hline(yintercept = 1, colour="grey") +
geom_jitter(alpha=0.2, size=0.8, width=0.05) +
geom_line(stat="smooth", method=lm, alpha=0.9) +
scale_y_log10() +
scale_colour_viridis_d(option = "viridis", end=0.85) +
labs(title="Resistance", colour="Inoculated\nRichness",
y="Effect size on Total Density+epsilon", x="Heat Duration (hrs)"))
# plot the preferred model
plot(ggplot(effectSize %>%
filter(Last_Heat_Day == TRUE),
aes(x=Heat,
y=TotDen_plusEpsilon_mean,
colour=CommRich,
group=CommRich)) +
facet_grid(~protegens) +
geom_hline(yintercept = 1, colour="grey") +
geom_jitter(alpha=0.2, size=0.8, width=0.05) +
geom_line(stat="smooth", method=lm, alpha=0.9) +
scale_y_log10() +
scale_colour_viridis_d(option = "viridis", end=0.85) +
labs(title="Resistance (protegens present?)", colour="Inoculated\nRichness",
y="Effect size on Total Density+epsilon", x="Heat Duration (hrs)"))
# clean up
rm(resist_prod0, resist_prod1, resist_prod2)
#####################
# log10(Total Density + epsilon) transformed data
#####################
recov_prod0 <- with(effectSize %>% filter(Recov_Day == 2) %>%
mutate(log_TotalDensity_plusE = log(TotDen_plusEpsilon_mean)),
lm(log_TotalDensity_plusE ~ CommRich + Heat + CommRich:Heat))
# Maddy's preferred model
print("RECOVERY PRODUCTIVITY DATA. SUMMARY OF THE SIMPLEST MODEL:")
summary(recov_prod0)
recov_prod1 <- with(effectSize %>% filter(Recov_Day == 2) %>%
mutate(log_TotalDensity_plusE = log(TotDen_plusEpsilon_mean)),
lm(log_TotalDensity_plusE ~ CommRich + withstands_heat + Heat + CommRich:withstands_heat + Heat:withstands_heat + CommRich:Heat))
recov_prod2 <- with(effectSize %>% filter(Recov_Day == 2) %>%
mutate(log_TotalDensity_plusE = log(TotDen_plusEpsilon_mean)),
lm(log_TotalDensity_plusE ~ CommRich + protegens + Heat + CommRich:protegens + Heat:protegens + CommRich:Heat))
# compare the nested models
anova(recov_prod0, recov_prod1)
anova(recov_prod0, recov_prod2)
# compare all 3 models
AIC(recov_prod0, recov_prod1, recov_prod2) %>% arrange(AIC)
BIC(recov_prod0, recov_prod1, recov_prod2) %>% arrange(BIC)
# the statistically preferred model
print("")
print("RECOVERY PRODUCTIVITY DATA. SUMMARY OF THE LOWEST AIC & BIC MODEL:")
print("")
summary(recov_prod2)
plot(recov_prod2)
# clean up
rm(recov_prod0, recov_prod1, recov_prod2)
# plot Maddy's preferred model
plot(ggplot(effectSize %>%
filter(Recov_Day == 2),
aes(x=Heat,
y=Total_density_mean,
colour=CommRich,
group=CommRich)) +
geom_hline(yintercept = 1, colour="grey") +
geom_jitter(alpha=0.2, size=0.8, width=0.05) +
geom_line(stat="smooth", method=lm, alpha=0.9) +
scale_y_log10() +
scale_colour_viridis_d(option = "viridis", end=0.85) +
labs(title="Recovery", colour="Inoculated\nRichness",
y="Effect size on Total density", x="Heat Duration (hrs)"))
# plot a preferred model
plot(ggplot(effectSize %>%
filter(Recov_Day == 2),
aes(x=Heat,
y=Total_density_mean,
colour=CommRich,
group=CommRich)) +
facet_grid(~protegens) +
geom_hline(yintercept = 1, colour="grey") +
geom_jitter(alpha=0.2, size=0.8, width=0.05) +
geom_line(stat="smooth", method=lm, alpha=0.9) +
scale_y_log10() +
scale_colour_viridis_d(option = "viridis", end=0.85) +
labs(title="Recovery (protegens present?)", colour="Inoculated\nRichness",
y="Effect size on Total density", x="Heat Duration (hrs)"))
# plot a preferred model
plot(ggplot(effectSize %>%
filter(Recov_Day == 2),
aes(x=Heat,
y=Total_density_mean,
colour=CommRich,
group=CommRich)) +
facet_grid(~withstands_heat) +
geom_hline(yintercept = 1, colour="grey") +
geom_jitter(alpha=0.2, size=0.8, width=0.05) +
geom_line(stat="smooth", method=lm, alpha=0.9) +
scale_y_log10() +
scale_colour_viridis_d(option = "viridis", end=0.85) +
labs(title="Recovery (withstands heat? AKA putida present?)", colour="Inoculated\nRichness",
y="Effect size on Total density", x="Heat Duration (hrs)"))
#####################
# log10(Total Density + epsilon) transformed data
#####################
overrecov0 <- with(effectSize %>% filter(Recov_Day == 1) %>%
mutate(log_TotalDensity_plusE = log(TotDen_plusEpsilon_mean)),
lm(log_TotalDensity_plusE ~ CommRich + Heat + CommRich:Heat))
# Maddy's preferred model
print("DAY1 RECOVERY PRODUCTIVITY DATA. SUMMARY OF THE SIMPLEST MODEL:")
summary(overrecov0)
overrecov1 <- with(effectSize %>% filter(Recov_Day == 1) %>%
mutate(log_TotalDensity_plusE = log(TotDen_plusEpsilon_mean)),
lm(log_TotalDensity_plusE ~ CommRich + withstands_heat + Heat + CommRich:withstands_heat + Heat:withstands_heat + CommRich:Heat))
overrecov2 <- with(effectSize %>% filter(Recov_Day == 1) %>%
mutate(log_TotalDensity_plusE = log(TotDen_plusEpsilon_mean)),
lm(log_TotalDensity_plusE ~ CommRich + protegens + Heat + CommRich:protegens + Heat:protegens + CommRich:Heat))
# compare nested models
anova(overrecov0, overrecov1)
anova(overrecov0, overrecov2)
# which is the best one?
AIC(overrecov0, overrecov1, overrecov2) %>% arrange(AIC)
BIC(overrecov0, overrecov1, overrecov2) %>% arrange(BIC)
# the statistically preferred model
print("")
print("DAY1 RECOVERY PRODUCTIVITY DATA. SUMMARY OF THE LOWEST AIC & BIC MODEL:")
print("")
summary(overrecov2)
plot(overrecov2)
# clean up
rm(overrecov0, overrecov1, overrecov2)
# plot Maddy's preferred model
plot(ggplot(effectSize %>% filter(Recov_Day == 1),
aes(x=Heat, y=Total_density_mean,
colour=CommRich, group=CommRich)) +
scale_y_log10() +
geom_hline(yintercept = 1, colour="grey") +
geom_jitter(alpha=0.2, size=0.8, width=0.1) +
geom_line(stat="smooth", method=lm, alpha=0.9) +
scale_colour_viridis_d(option = "viridis", end=0.85) +
labs(title="Day 1 of Recovery", colour="Inoculated\nRichness",
y="Effect size on Total density"))
# plot the preferred model
plot(ggplot(effectSize %>% filter(Recov_Day == 1),
aes(x=Heat, y=Total_density_mean,
colour=CommRich, group=CommRich)) +
facet_grid(~protegens) +
scale_y_log10() +
geom_hline(yintercept = 1, colour="grey") +
geom_jitter(alpha=0.2, size=0.8, width=0.1) +
geom_line(stat="smooth", method=lm, alpha=0.9) +
scale_colour_viridis_d(option = "viridis", end=0.85) +
labs(title="Day 1 of Recovery (protegens present?)", colour="Inoculated\nRichness",
y="Effect size on Total density"))
# clean up
rm(effectSize)
# scale the data by its standard deviation
absDen_forFit$TotDensity_scale <- scale(absDen_forFit$Total_density,
scale = sd(absDen_forFit$Total_density, na.rm = TRUE),
center = FALSE)
# the max scaled value is ~7.9 and almost 3% of the data is 0 values
summary(absDen_forFit$TotDensity_scale)
sum(absDen_forFit$TotDensity_scale == 0) / length(absDen_forFit$TotDensity_scale)
# in fact, the total density data is even more long-tailed than the diversity data. I guess that makes sense as there is a max value for the possible diversity with 4 species.
hist(absDen_forFit$TotDensity_scale)
# re-arrange the levels so that emmeans can be run:
absDen_forFit$Heat <- as.character(absDen_forFit$Heat)
absDen_forFit$Heat[which(absDen_forFit$Heat == 0)] <- "control"
# !!! emmeans expects the control to be the very *last* level !!!
absDen_forFit$Heat <- factor(absDen_forFit$Heat,
levels = c("6", "12", "24", "48", "control"))
# let's keep CommRich and Day as numeric for now while we look for the best fitting GLM family
# let's compare different GLM families
try_gaussian <- glmmTMB(TotDensity_scale ~ CommRich*Heat*Day*protegens,
data = absDen_forFit,
control = glmmTMBControl(optCtrl = list(iter.max = 10000,eval.max = 10000)))
simulateResiduals(fittedModel = try_gaussian, plot = TRUE)
try_gamma <- glmmTMB(TotDensity_scale ~ CommRich*Heat*Day*protegens,
data = absDen_forFit,
family = ziGamma,
ziformula = ~1, # this needs to be added because there are 0 values in the data
control = glmmTMBControl(optCtrl = list(iter.max = 500000,eval.max = 500000)))
simulateResiduals(fittedModel = try_gamma, plot = TRUE)
try_lognorm <- glmmTMB(TotDensity_scale ~ CommRich*Heat*Day*protegens,
data = absDen_forFit,
family = lognormal,
ziformula = ~1, # this needs to be added because there are 0 values in the data
control = glmmTMBControl(optCtrl = list(iter.max = 500000,eval.max = 500000)))
simulateResiduals(fittedModel = try_lognorm, plot = TRUE)
try_LOGlognorm <- glmmTMB(log(TotDensity_scale + 1) ~ CommRich*Heat*Day*protegens,
data = absDen_forFit,
family = lognormal,
ziformula = ~1, # I'm keeping this as 0-inflated lognormal alone was already over-dispersed. So I want to see if the log(x+1) transformation sufficiently brings in the long tail.
control = glmmTMBControl(optCtrl = list(iter.max = 500000,eval.max = 500000)))
simulateResiduals(fittedModel = try_LOGlognorm, plot = TRUE)
try_negbinom <- glmmTMB(as.integer(TotDensity_scale * 1000) ~ CommRich*Heat*Day*protegens,
data = absDen_forFit,
family = nbinom2,
control = glmmTMBControl(optCtrl = list(iter.max = 10000,eval.max = 10000)))
simulateResiduals(fittedModel = try_negbinom, plot = TRUE)
try_negbinom0 <- glmmTMB(as.integer(Total_density * 1000) ~ CommRich*Heat*Day*protegens,
data = absDen_forFit,
family = nbinom2,
ziformula = ~1, # try zero inflated distribution
control = glmmTMBControl(optCtrl = list(iter.max = 10000,eval.max = 10000)))
simulateResiduals(fittedModel = try_negbinom0, plot = TRUE)
try_poisson <- glmmTMB(as.integer(TotDensity_scale * 1000) ~ CommRich*Heat*Day*protegens,
data = absDen_forFit,
family = genpois,
control = glmmTMBControl(optCtrl = list(iter.max = 10000,eval.max = 10000)))
simulateResiduals(fittedModel = try_poisson, plot = TRUE)
try_poisson0 <- glmmTMB(as.integer(TotDensity_scale * 1000) ~ CommRich*Heat*Day*protegens,
data = absDen_forFit,
family = genpois,
ziformula = ~1, # try zero inflated distribution
control = glmmTMBControl(optCtrl = list(iter.max = 10000,eval.max = 10000)))
simulateResiduals(fittedModel = try_poisson0, plot = TRUE)
# let's check this with AIC and BIC
AIC(try_gaussian, try_gamma, try_lognorm, try_LOGlognorm,
try_negbinom, try_negbinom0, try_poisson, try_poisson0) %>% arrange(AIC)
BIC(try_gaussian, try_gamma, try_lognorm, try_LOGlognorm,
try_negbinom, try_negbinom0, try_poisson, try_poisson0) %>% arrange(BIC)
# clean up
rm(try_gaussian, try_gamma, try_lognorm, try_LOGlognorm, try_negbinom, try_negbinom0, try_poisson, try_poisson0)
####################
# 6h heat duration
####################
# grab just the treatment with its associated control data
absDen_6h <- rbind(absDen_forFit %>% filter(Heat == "6"),
absDen_forFit %>% filter(Heat == "control", Day < 4))
# create a column for last day of heat, first day of recovery, and last day of recovery
absDen_6h$Trtmt_Day <- "resist"
absDen_6h$Trtmt_Day[absDen_6h$Day == 2] <- "recov_1"
absDen_6h$Trtmt_Day[absDen_6h$Day == 3] <- "recov_2"
# try changing CommRich to unordered factor
absDen_6h$CommRich <- factor(absDen_6h$CommRich, ordered = FALSE)
# save the data to storage for later
productivitySubsettedData <- list(h6 = absDen_6h)
# try dropping inoculated community richness = 4 because it's unitary (i.e., it get dropped by glmmTMB then eff_size complains that it can't do anything with the resultant NA estimate values)
absDen_6h <- absDen_6h %>% filter(CommRich != 4)
absDen_6h$CommRich <- droplevels(absDen_6h$CommRich)
productivity6h_H0 <- glmmTMB(as.integer(TotDensity_scale * 1000) ~ CommRich*Heat*Trtmt_Day,
data = absDen_6h,
family = genpois,
control = glmmTMBControl(optCtrl = list(iter.max = 500000,eval.max = 500000)))
simulateResiduals(fittedModel = productivity6h_H0, plot = TRUE)
productivity6h_H1 <- glmmTMB(as.integer(TotDensity_scale * 1000) ~ CommRich*Heat*Trtmt_Day + putida*CommRich + putida*Heat,
data = absDen_6h,
family = genpois,
control = glmmTMBControl(optCtrl = list(iter.max = 500000,eval.max = 500000)))
simulateResiduals(fittedModel = productivity6h_H1, plot = TRUE)
productivity6h_H2 <- glmmTMB(as.integer(TotDensity_scale * 1000) ~ CommRich*Heat*Trtmt_Day + protegens*CommRich + protegens*Heat,
data = absDen_6h,
family = genpois,
control = glmmTMBControl(optCtrl = list(iter.max = 500000,eval.max = 500000)))
simulateResiduals(fittedModel = productivity6h_H2, plot = TRUE)
# check preferred models
anova(productivity6h_H0, productivity6h_H1)
anova(productivity6h_H0, productivity6h_H2)
AIC(productivity6h_H0, productivity6h_H1, productivity6h_H2) %>% arrange(AIC)
BIC(productivity6h_H0, productivity6h_H1, productivity6h_H2) %>% arrange(BIC)
# H2 is the preferred model
summary(productivity6h_H2)
# create data.frame for plotting
prod_predict <- cbind(productivity6h_H2$frame,
predict(productivity6h_H2, type="response"))
colnames(prod_predict)[c(1,6)] <- c("observed", "predicted")
# and remember to divide by 1000 as we did for transforming the data
prod_predict[,c(1,6)] <- prod_predict[,c(1,6)]/1000
# plot the model predictions against the data
ggplot(prod_predict,
aes(x=Trtmt_Day, y=observed, colour=CommRich)) +
facet_grid(protegens~Heat) +
geom_jitter(alpha=0.4) +
geom_line(aes(y=predicted, group=CommRich)) +
scale_colour_viridis_d(option = "viridis", begin=0.1, end=0.85) +
labs(y="Total density (rescaled)",
colour="CommRich")
# cleanup
rm(prod_predict)
####################
# 12h heat duration
####################
# grab just the treatment with its associated control data
absDen_12h <- rbind(absDen_forFit %>% filter(Heat == "12", Day > 1),
absDen_forFit %>% filter(Heat == "control", Day > 1, Day !=5))
# create a column for last day of heat, first day of recovery, and last day of recovery
absDen_12h$Trtmt_Day <- "resist"
absDen_12h$Trtmt_Day[absDen_12h$Day == 3] <- "recov_1"
absDen_12h$Trtmt_Day[absDen_12h$Day == 4] <- "recov_2"
# change CommRich to unordered factor
absDen_12h$CommRich <- factor(absDen_12h$CommRich, ordered = FALSE)
# save the data to storage for later
productivitySubsettedData[["h12"]] <- absDen_12h
# drop inoculated community richness = 4 because it is unitary for models H1 and H2
absDen_12h <- absDen_12h %>% filter(CommRich != 4)
absDen_12h$CommRich <- droplevels(absDen_12h$CommRich)
productivity12h_H0 <- glmmTMB(as.integer(TotDensity_scale * 1000) ~ CommRich*Heat*Trtmt_Day,
data = absDen_12h,
family = genpois,
control = glmmTMBControl(optCtrl = list(iter.max = 500000,eval.max = 500000)))
simulateResiduals(fittedModel = productivity12h_H0, plot = TRUE)
productivity12h_H1 <- glmmTMB(as.integer(TotDensity_scale * 1000) ~ CommRich*Heat*Trtmt_Day + putida*CommRich + putida*Heat,
data = absDen_12h,
family = genpois,
control = glmmTMBControl(optCtrl = list(iter.max = 500000,eval.max = 500000)))
simulateResiduals(fittedModel = productivity12h_H1, plot = TRUE)
productivity12h_H2 <- glmmTMB(as.integer(TotDensity_scale * 1000) ~ CommRich*Heat*Trtmt_Day + protegens*CommRich + protegens*Heat,
data = absDen_12h,
family = genpois,
control = glmmTMBControl(optCtrl = list(iter.max = 500000,eval.max = 500000)))
simulateResiduals(fittedModel = productivity12h_H2, plot = TRUE)
# check preferred models
anova(productivity12h_H0, productivity12h_H1)
anova(productivity12h_H0, productivity12h_H2)
AIC(productivity12h_H0, productivity12h_H1, productivity12h_H2) %>% arrange(AIC)
BIC(productivity12h_H0, productivity12h_H1, productivity12h_H2) %>% arrange(BIC)
# H2 is the preferred model
summary(productivity12h_H2)
# create data.frame for plotting
prod_predict <- cbind(productivity12h_H2$frame,
predict(productivity12h_H2, type="response"))
colnames(prod_predict)[c(1,6)] <- c("observed", "predicted")
# and remember to divide by 1000 as we did for transforming the data
prod_predict[,c(1,6)] <- prod_predict[,c(1,6)]/1000
# plot the model predictions against the data
ggplot(prod_predict,
aes(x=Trtmt_Day, y=observed, colour=CommRich)) +
facet_grid(protegens~Heat) +
geom_jitter(alpha=0.4) +
geom_line(aes(y=predicted, group=CommRich)) +
scale_colour_viridis_d(option = "viridis", begin=0.1, end=0.85) +
labs(y="Total density (rescaled)",
colour="CommRich")
# cleanup
rm(prod_predict)
####################
# 24h heat duration
####################
# grab just the treatment with its associated control data
absDen_24h <- rbind(absDen_forFit %>% filter(Heat == "24", Day > 1),
absDen_forFit %>% filter(Heat == "control", Day > 1, Day !=5))
# create a column for last day of heat, first day of recovery, and last day of recovery
absDen_24h$Trtmt_Day <- "resist"
absDen_24h$Trtmt_Day[absDen_24h$Day == 3] <- "recov_1"
absDen_24h$Trtmt_Day[absDen_24h$Day == 4] <- "recov_2"
# change CommRich to unordered factor
absDen_24h$CommRich <- factor(absDen_24h$CommRich, ordered = FALSE)
# save the data to storage for later
productivitySubsettedData[["h24"]] <- absDen_24h
# drop inoculated community richness = 4 because it is unitary for models H1 and H2
absDen_24h <- absDen_24h %>% filter(CommRich != 4)
absDen_24h$CommRich <- droplevels(absDen_24h$CommRich)
productivity24h_H0 <- glmmTMB(as.integer(TotDensity_scale * 1000) ~ CommRich*Heat*Trtmt_Day,
data = absDen_24h,
family = genpois,
control = glmmTMBControl(optCtrl = list(iter.max = 500000,eval.max = 500000)))
simulateResiduals(fittedModel = productivity24h_H0, plot = TRUE)
productivity24h_H1 <- glmmTMB(as.integer(TotDensity_scale * 1000) ~ CommRich*Heat*Trtmt_Day + putida*CommRich + putida*Heat,
data = absDen_24h,
family = genpois,
control = glmmTMBControl(optCtrl = list(iter.max = 500000,eval.max = 500000)))
simulateResiduals(fittedModel = productivity24h_H1, plot = TRUE)
